import org.slf4j.LoggerFactory
import org.springframework.cache.interceptor.*
import org.springframework.stereotype.Component
import java.lang.reflect.Method
import kotlin.system.measureTimeMillis

class LoggingCacheAspect : CacheAspectSupport() {

    private val logger = LoggerFactory.getLogger(LoggingCacheAspect::class.java)

    override fun invokeOperation(context: CacheOperationInvocationContext<CacheOperation>): Any? {
        val method: Method = context.method
        val cacheNames = context.operation.cacheNames
        val key = generateKey(context)

        var result: Any?
        val time = measureTimeMillis {
            result = super.invokeOperation(context)
        }

        logger.info(
            "Cache operation '${method.name}' with cache(s) '${cacheNames.joinToString()}' and key '$key' took ${time}ms"
        )
        return result
    }

    private fun generateKey(context: CacheOperationInvocationContext<CacheOperation>): Any? {
        return keyGenerator.generate(context.target, context.method, *context.args)
    }
}



import org.springframework.cache.annotation.EnableCaching
import org.springframework.cache.interceptor.*
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator

@Configuration
@EnableCaching
class CacheConfig {

    @Bean
    fun loggingCacheAspect(
        cacheResolver: CacheResolver,
        keyGenerator: KeyGenerator,
        errorHandler: CacheErrorHandler
    ): LoggingCacheAspect {
        val aspect = LoggingCacheAspect()
        aspect.setCacheResolver(cacheResolver)
        aspect.setKeyGenerator(keyGenerator)
        aspect.setErrorHandler(errorHandler)
        return aspect
    }

    @Bean
    fun cacheAdvisor(loggingCacheAspect: LoggingCacheAspect): CacheInterceptor {
        val interceptor = CacheInterceptor()
        interceptor.setCacheOperationSource(loggingCacheAspect.cacheOperationSource)
        interceptor.setCacheResolver(loggingCacheAspect.cacheResolver)
        interceptor.setKeyGenerator(loggingCacheAspect.keyGenerator)
        interceptor.setErrorHandler(loggingCacheAspect.errorHandler)
        return interceptor
    }

    @Bean
    fun cacheAdvisorProxy(): BeanNameAutoProxyCreator {
        val proxyCreator = BeanNameAutoProxyCreator()
        proxyCreator.setBeanNames("*Service", "*Repository") // adjust as needed
        proxyCreator.setInterceptorNames("cacheAdvisor")
        return proxyCreator
    }
}
