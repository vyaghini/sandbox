import org.slf4j.LoggerFactory
import org.springframework.cache.interceptor.CacheInterceptor
import org.springframework.cache.interceptor.CacheOperationInvocationContext
import org.springframework.cache.interceptor.CacheOperationInvoker
import org.springframework.stereotype.Component
import kotlin.system.measureTimeMillis

class LoggingCacheInterceptor : CacheInterceptor() {

    private val logger = LoggerFactory.getLogger(LoggingCacheInterceptor::class.java)

    override fun execute(invoker: CacheOperationInvoker, context: CacheOperationInvocationContext<*>): Any? {
        var result: Any? = null
        val time = measureTimeMillis {
            result = super.execute(invoker, context)
        }
        val operation = context.operation
        val methodName = context.method.name
        val cacheNames = operation.cacheNames.joinToString()
        val cacheKey = context.key

        logger.info(
            "Cache operation on method '$methodName' with key '$cacheKey' and cache(s) '$cacheNames' took ${time}ms"
        )
        return result
    }
}



import org.springframework.cache.annotation.EnableCaching
import org.springframework.cache.interceptor.CacheInterceptor
import org.springframework.cache.interceptor.CacheResolver
import org.springframework.cache.interceptor.CacheErrorHandler
import org.springframework.cache.interceptor.KeyGenerator
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
@EnableCaching
class CacheConfig {

    @Bean
    fun cacheInterceptor(
        cacheResolver: CacheResolver,
        keyGenerator: KeyGenerator,
        errorHandler: CacheErrorHandler
    ): CacheInterceptor {
        val interceptor = LoggingCacheInterceptor()
        interceptor.setCacheResolver(cacheResolver)
        interceptor.setKeyGenerator(keyGenerator)
        interceptor.setErrorHandler(errorHandler)
        return interceptor
    }
}
